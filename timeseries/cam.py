# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/82_univariate_timeseries_CAM.ipynb (unless otherwise specified).

__all__ = ['hooked_backward', 'hook_acts', 'cam_acts', 'acts_scaled', 'cam_acts_colors', 'grad_cam_acts',
           'grad_cam_acts_colors', 'plot_cam', 'CAM_batch_plot_one_fig_1', 'CAM_compute_batch',
           'CAM_batch_plot_one_fig', 'CAM_batch_plot_multi_fig', 'compute_plot_cam', 'batch_compute_plot_cam']

# Cell
def hooked_backward(x, y, model, layer):
    "A hook to get access to both activation and gradient values of the given `model` at the layer number `layer`"
    xb= x[None, :] # xb = x.unsqueeze()
    with hook_output(model[layer]) as hook_a:
        with hook_output(m[layer], grad=True) as hook_g:
            preds = m(xb)
            preds[0,int(y)].backward()
    return hook_a,hook_g

# Cell
def hook_acts(x, y, model, layer):
    "A hook to get access to activation values of the given `model` at the layer number `layer`"
    hook_a,hook_g = hooked_backward(x, y, model, layer)
    acts  = hook_a.stored[0].cpu()
    return acts

# Cell
def cam_acts(x, y, model, layer, reduction='mean', force_scale=True, scale_range=(0, 1)): # x.shape = [1, 150]
    "Compute raw CAM values. `reduction` : string. One of ['mean', 'median', 'max', 'mean_max']. 'mean_max corresponds to       (mean + max)/2"
    acts = hook_acts(x, y, model, layer) # acts.shape = [128, 150]

    if reduction=='mean': acts = acts.mean(0)                  # mean.shape = [150]
    if reduction=='median': acts = acts.median(0).values         # mendia.shape = [150]
    if reduction=='max' : acts = acts.max(0).values      # max.shape = [150]
    if reduction=='mean_max': acts = (acts.mean(0) + acts.max(0).values)/2 # max_mean.shape = [150]
    # print(f'Reduction: {reduction}')

    if force_scale==True:
        acts = (acts - acts.min())/(acts.max() - acts.min())*(scale_range[1] - scale_range[0]) + scale_range[0]
        return acts[None, :]
    else:
        return acts[None, :]

# store function name
cam_acts.name = r'CAM'

# Cell
def acts_scaled(acts, scale_range=(0, 1)):
    "Scale values between [0...1]"
    return (acts - acts.min())/(acts.max() - acts.min())*(scale_range[1] - scale_range[0]) + scale_range[0]


# Cell
def cam_acts_colors(x, y, model, layer, reduction='mean'):
    "Compute raw CAM values and convert them to scaled values in one operation. Scaled values are float values between           [0...1]. `reduction` : string. One of ['mean', 'median', 'max', 'mean_max']. 'mean_max corresponds to (mean + max)/2"
    ts = cam_acts(x, y, model, layer,reduction=reduction)
    return acts_to_colors(ts)


# Cell
def grad_cam_acts(x, y, model, layer, reduction='mean', force_scale=True, scale_range=(0, 1)): # x.shape = [1, 150]
    "Compute raw GRA-CAM values. `reduction` : string. One of ['mean', 'median', 'max', 'mean_max']. 'mean_max corresponds       to (mean + max)/2"
    hook_a,hook_g = hooked_backward(x, y, model, layer)

    acts  = hook_a.stored[0].cpu()      # acts.shape = [128, 150]
    grad = hook_g.stored[0][0].cpu()    # grad.shape = [128, 150]

    # grad_chan.shape = [128]
    if reduction=='mean': grad_chan = grad.mean(1)
    if reduction=='median': grad_chan = grad.median(1).values
    if reduction=='max': grad_chan = grad.max(1).values
    if reduction=='mean_max': grad_chan = (grad.mean(1) + grad.max(1).values)/2
    # print(f'Reduction: {reduction}')

    mult = (acts*grad_chan[..., None])  # shape grad_chan[..., None] => [128, 1] => broadcast to => [128, 150]
    acts = mult.mean(0)                 # mean.shape = [150]

    if force_scale==True:
        acts = (acts - acts.min())/(acts.max() - acts.min())*(scale_range[1] - scale_range[0]) + scale_range[0]
        return acts[None, :]    # acts.shape = [1, 150]
    else:
        return acts[None, :]    # acts.shape = [1, 150]

# store function name
grad_cam_acts.name = r'GRAD-CAM'

# Cell
def grad_cam_acts_colors(x, y, model, layer, reduction='mean'):
    "Compute raw GRA-CAM values and convert them to scaled values in one operation. Scaled values are float values between       [0...1]. `reduction` : string. One of ['mean', 'median', 'max', 'mean_max']. 'mean_max corresponds to (mean + max)/2"

    grad_cam = grad_cam_acts(x, y, model, layer, reduction=reduction)
    return acts_scaled(grad_cam)

# Cell
@delegates(LineCollection.__init__)
def plot_cam(tseries, y, acts, title=None, cmap="Spectral_r", linewidth=3, linestyles='solid', alpha=1.0, scatter=False, i2o=noop,**kwargs):
    'Plot a tseries using either CAM or GRAD-CAM'
    """
    linestyles : string, tuple, optional
            Either one of [ 'solid' | 'dashed' | 'dashdot' | 'dotted' ], or
            a dash tuple. The dash tuple is: (offset, onoffseq)
            where ``onoffseq`` is an even length tuple of on and off ink in points.
    """
    tseries = tseries.squeeze().numpy()
    acts = acts.squeeze().numpy()
    t = np.arange(tseries.shape[-1])

    if title is None:
        title = y
    if scatter==True:
        plt.scatter(t, tseries, cmap=cmap, c = acts)
    else:
        points = np.array([t, tseries]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)

        levels = 254
        cmap = plt.get_cmap(cmap, lut=levels) #seismic
        colors = cmap(np.linspace(0, 1, levels))
        norm = BoundaryNorm(np.linspace(0, 1, levels+1), len(colors))

        lc = LineCollection(segments, cmap=cmap, norm=norm, linewidth=linewidth, linestyles=linestyles, alpha=alpha,                        **kwargs )
        lc.set_array(acts)
        lc.set_linewidth(3)
        plt.gca().add_collection(lc)

        plt.xlim(t.min(), t.max())
        plt.ylim(tseries.min()*1.2, tseries.max()*1.2)
        plt.title(title)

        # setup the colorbar
        import matplotlib.cm as cm
        scalarmappaple = cm.ScalarMappable(norm=norm, cmap=cmap)
        scalarmappaple.set_array(acts)
        plt.colorbar(scalarmappaple)

        plt.show()

# Cell
@delegates(LineCollection.__init__)
def CAM_batch_plot_one_fig_1(b, model, layer=5, func_cam=grad_cam_acts, reduction='mean', cmap="Spectral_r", linewidth=3, linestyles='solid',                              alpha=1.0, scatter=False, i2o=noop, **kwargs):

    'Compute either CAM or GRAD-CAM and plot a batch of colored time series `tseries`. The colors correspond to the scaled      [0..1] CAM or GRAD-CAM values. The time series are plot on a single figure'

    b = _listify(b)
    if scatter==True:
        plt.scatter(t, tseries, cmap=cmap, c = acts)
    else:
        # cmap, colors, norm
        levels = 254
        cmap = plt.get_cmap(cmap, lut=levels) #seismic
        colors = cmap(np.linspace(0, 1, levels))
        norm = BoundaryNorm(np.linspace(0, 1, levels+1), len(colors))

        tsmin, tsmax = 1e10, -1e10
        ys = []
        # Process one time series at the time
        for item in b:
            tseries, y = item
            ys.append(y)
            acts = func_cam(tseries, y, m, layer=layer, reduction=reduction)
            # acts = acts_to_colors(acts)

            acts = acts.squeeze().numpy()
            # Create segments using t array (x-axis) and tseries (y-axis)
            tseries = tseries.squeeze().numpy()
            t = np.arange(tseries.shape[-1])
            points = np.array([t, tseries]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)

            lc = LineCollection(segments, cmap=cmap, norm=norm, linewidth=linewidth, linestyles=linestyles, alpha=alpha,                        **kwargs )
            lc.set_array(acts)
            lc.set_linewidth(linewidth)
            plt.gca().add_collection(lc)

            # set tsmin and tsmax
            min, max = tseries.min(), tseries.max()
            # print('min - max', min, max)
            if min<tsmin: tsmin = min
            if max>tsmax: tsmax = max
            # print('tsmin - tsmax', min, max)

        titles = [i2o(y) for y in ys]
        title = ' - '.join(titles)
        if not hasattr(func_cam, 'name'): func_cam.name = str(func_cam)
        title =  f'[{title}] - {func_cam.name} - {reduction}'

        # x.lim and y.lim
        plt.xlim(t.min(), t.max())
        plt.ylim(tsmin*1.2, tsmax*1.2)
        plt.title(title)

        # setup the colorbar
        import matplotlib.cm as cm
        scalarmappaple = cm.ScalarMappable(norm=norm, cmap=cmap)
        scalarmappaple.set_array(acts)
        plt.colorbar(scalarmappaple)

        plt.show()


# Cell
@delegates(LineCollection.__init__)
def CAM_compute_batch(b, model, layer=5, func_cam=grad_cam_acts, reduction='mean', **kwargs):

    'Compute either CAM or GRAD-CAM for a batch of time series `tseries`.'

    tsmin, tsmax = 1e10, -1e10
    tseries_list = []
    y_list = []
    acts_list = []
    idx = 1
    # Compute activation for each time series `tseries` here below
    # Process one time series at the time
    for item in b:
        # print(f'idx = {idx}')
        tseries, y = item
        y_list.append(y)
        acts = func_cam(tseries, y, m, layer=layer, reduction=reduction)
        # acts = acts_to_colors(acts)

        # remove the first dimension : [1, 150] -> [150]
        acts = acts.squeeze().numpy()
        tseries = tseries.squeeze().numpy()

        tseries_list.append(tseries)
        acts_list.append(acts)

        # set tsmin and tsmax
        min, max = tseries.min(), tseries.max()
        # print('min - max', min, max)
        if min<tsmin: tsmin = min
        if max>tsmax: tsmax = max
        # print('tsmin - tsmax', min, max)
        idx += 1

    return (tseries_list, acts_list, y_list, tsmin, tsmax)


# Cell
@delegates(LineCollection.__init__)
def CAM_batch_plot_one_fig(b, model, layer=5, func_cam=grad_cam_acts, reduction='mean', cmap="Spectral_r", linewidth=3,                                         linestyles='solid', alpha=1.0, scatter=False, i2o=noop, figsize=(13,4), **kwargs):

    'Compute either CAM or GRAD-CAM and plot a batch of colored time series `tseries`. The colors correspond to the scaled      [0..1] CAM or GRAD-CAM values. The time series are plot on a single figure'

    plt.figure(figsize=figsize)
    b = _listify(b)
    levels = 254
    cmap = plt.get_cmap(cmap, lut=levels) #seismic
    colors = cmap(np.linspace(0, 1, levels))
    norm = BoundaryNorm(np.linspace(0, 1, levels+1), len(colors))

    tseries_list, acts_list, y_list, tsmin, tsmax = CAM_compute_batch(b, model, layer=layer, func_cam=func_cam,                                                                                    reduction=reduction, **kwargs)
    # Plot activation `acts` (superimposed on the original time series `tseries)
    idx = 1
    for tseries, acts, y in zip(tseries_list, acts_list, y_list):
        t = np.arange(tseries.shape[-1])
        if scatter==True:
            # plt.figure(figsize=(13,4))
            # plt.subplot(1, 2, idx)
            plt.scatter(t, tseries, cmap=cmap, c = acts, linewidths=linewidth )
            idx += 1
        else:
            points = np.array([t, tseries]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            lc = LineCollection(segments, cmap=cmap, norm=norm, linewidth=linewidth, linestyles=linestyles, alpha=alpha,                                    **kwargs )
            lc.set_array(acts)
            lc.set_linewidth(linewidth)
            plt.gca().add_collection(lc)
            idx += 1

    plt.xlim(t.min(), t.max())
    plt.ylim(tsmin*1.2, tsmax*1.2)

    titles = [i2o(y) for y in y_list]
    title = ' - '.join(titles)
    if not hasattr(func_cam, 'name'): func_cam.name = str(func_cam)
    title =  f'[{title}] - {func_cam.name} - {reduction}'
    # print(f'Title: {title}')
    plt.title(title)

    scalarmappaple = cm.ScalarMappable(norm=norm, cmap=cmap)
    scalarmappaple.set_array(acts)
    plt.colorbar(scalarmappaple)
    plt.show()



# Cell
@delegates(LineCollection.__init__)
def CAM_batch_plot_multi_fig(b, model, layer=5, func_cam=grad_cam_acts, reduction='mean', cmap="Spectral_r", linewidth=3,                                       linestyles='solid', alpha=1.0, scatter=False, i2o=noop, figsize=(13,4), **kwargs):

    'Compute either CAM or GRAD-CAM and plot a batch of colored time series `tseries`. The colors correspond to the scaled      [0..1] CAM or GRAD-CAM values. Each time series is plotted on a separate figure'

    # This allows to consum either a list of items or a single item
    b = _listify(b)

    levels = 254
    cmap = plt.get_cmap(cmap, lut=levels) #seismic
    colors = cmap(np.linspace(0, 1, levels))
    norm = BoundaryNorm(np.linspace(0, 1, levels+1), len(colors))

    tseries_list, acts_list, y_list, tsmin, tsmax = CAM_compute_batch(b, model, layer=layer, func_cam=func_cam,                                                                                    reduction=reduction, **kwargs)
    # Plot activation `acts` (superimposed on the original time series `tseries)
    idx = 1
    for tseries, acts, y in zip(tseries_list, acts_list, y_list):
        t = np.arange(tseries.shape[-1])
        if scatter==True:
            plt.figure(figsize=figsize)
            plt.subplot(1, 2, idx)
            plt.scatter(t, tseries, cmap=cmap, c = acts)
            title = i2o(y)
            if not hasattr(func_cam, 'name'): func_cam.name = str(func_cam)
            title =  f'[{title}] - {func_cam.name} - {reduction}'
            scalarmappaple = cm.ScalarMappable(norm=norm, cmap=cmap)
            scalarmappaple.set_array(acts)
            plt.colorbar(scalarmappaple)
            plt.show()
            idx += 1
        else:
            points = np.array([t, tseries]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)
            plt.figure(figsize=figsize)
            plt.subplot(1, 2, idx) # sharey='row'
            lc = LineCollection(segments, cmap=cmap, norm=norm, linewidth=linewidth, linestyles=linestyles, alpha=alpha,                                    **kwargs )
            lc.set_array(acts)
            lc.set_linewidth(linewidth)
            plt.gca().add_collection(lc)

            title = i2o(y)
            if not hasattr(func_cam, 'name'): func_cam.name = str(func_cam)
            title =  f'[{title}] - {func_cam.name} - {reduction}'

            plt.xlim(t.min(), t.max())
            plt.ylim(tsmin*1.2, tsmax*1.2)
            plt.title(title)
            scalarmappaple = cm.ScalarMappable(norm=norm, cmap=cmap)
            scalarmappaple.set_array(acts)
            plt.colorbar(scalarmappaple)
            plt.show()
            idx += 1

# Cell
@delegates(LineCollection.__init__)
def compute_plot_cam(tseries, y, model, layer=5, func_cam=grad_cam_acts, reduction='mean', cmap="Spectral_r", linewidth=3,                               alpha=1.0, scatter=False, i2o=noop, **kwargs):
    'Compute either CAM or GRAD-CAM and plot a colored time series `tseries`. The colors correspond to the scaled [0..1]         CAM or GRAD-CAM values'
    # if layer<0:
    #     # layer starts counting from the last children: -1 is the head, -2 is the last layer befor the head.
    #     # For InsceptiTime model layer=-2 corresponds to 5th layer
    #     layer = len(list(m.children())) + layer

    acts = func_cam(tseries, y, m, layer=layer, reduction=reduction)
    c = acts_to_colors(acts)

    title = i2o(y)
    # title =  f'{title} - {reduction}'
    title =  f'{title} - {func_cam.name} - {reduction}'
    # print(f'Title: {title}')

    plot_cam(tseries, y, c, title=title, cmap=cmap, linewidth=linewidth, alpha=alpha, scatter=scatter, i2o=i2o, **kwargs)

# Cell
@delegates(LineCollection.__init__)
def batch_compute_plot_cam(b, model, layer=5, func_cam=grad_cam_acts, reduction='mean', cmap="Spectral_r", linewidth=3,                               alpha=1.0, scatter=False, i2o=noop, **kwargs):
    'Compute either CAM or GRAD-CAM and plot a colored time series `tseries`. The colors correspond to the scaled [0..1]         CAM or GRAD-CAM values'

    for item in b:
        tseries, y = item
        compute_plot_cam(tseries, y, model, layer=layer, func_cam=func_cam, reduction=reduction, cmap=cmap,                                           linewidth=linewidth, alpha=alpha, scatter=scatter, i2o=i2o, **kwargs)